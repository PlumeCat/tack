Grammar:

	module
		stat-list
	
	stat-list
		stat stat-list

	stat
		if-stat
		for-in-stat
		var-decl
		assign-stat
		exp

	if-stat
		if-block
		if-block else-block
		
		if-block
			'if' exp block
		else-block
			'else' if-stat // chained else-if here
			'else' block   // terminating else

	for-in-stat
		'for' ident 'in' exp block
	
	block
		'{' stat-list '}'
	
	var-decl
		'let' ident '=' exp

	assign-stat
		locator '=' exp

	locator
		access-exp
		index-exp
		primary-exp

	exp:
		ternary-exp
			binary-exp '?' ternary-exp ':' ternary-exp
			binary-exp

	binary-exp
			or-exp		and-exp [ || or-exp ]			// left-assoc because of short circuiting
			and-exp		bit-or-exp [ && and-exp ]		// left-assoc because of short circuiting

			bit-or-exp	bit-xor-exp [ | bit-or-exp ]	// left assoc
			bit-xor-exp	bit-and-exp [ ^ bit-xor-exp ]	// associative
			bit-and-exp cmp-exp [ & bit-and-exp ]		// associative

			cmp-exp		shl-exp [ cmp-op cmp-exp ]		// TODO: don't allow chained comparisons a == b == c

			shl-exp		shr-exp [ << shl-exp ]			// left associative
			shr-exp		add-exp [ >> adr-exp ]			// left associative

			add-exp		sub-exp [ + add-exp ]			// associative
			sub-exp		mul-exp	[ - sub-exp ]			// left associative
			mul-exp		div-exp [ * mul-exp ]			// associative
			div-exp		mod-exp [ / div-exp ]			// left associative
			mod-exp		pow-exp [ % mod-exp ]			// left associative
			pow-exp		unary-exp [ ** pow-exp ]		// left associative
		
		unary-exp
			'-' unary-exp
			'!' unary-exp
			'~' unary-exp
			postfix-exp

		postfix-exp
			call-exp
			access-exp
			index-exp
			primary-exp

			call-exp
				postfix-exp '(' args-list ')'

			access-exp
				postfix-exp '.' identifier
		
			index-exp
				postfix-exp '[' exp ']'

		primary-exp
			literal
			identifier
			'(' exp ')'

		literal
			'null'
			'true'
			'false'
			literal-number
			literal-string
			literal-object
			literal-array
			literal-function
			

Types:
	scalarvalue types
		null:		null
		bool:		true, false
		int:		64 bit integer
		pointer:	32 or 64 bit opaque pointer for c/c++/(rust?) interop
		double		64 bit float
		string		utf8 string
					can do short string optimization
					can do interning for longer strings
		vector      2x or 3x or 4x
		matrix		{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 }

	ref types
		array		[ 0, 1, 2, ... ]
		object		{ a = 1, b = 2, ... }
		function	(x, y, z) {} // closures are passed by-ref as well

Notes:
	objects will need some kind of 'prototype' or 'index' field to implement classes

	array is not just object in disguise, it can be implemented completely differently (fast indexing, no holes, etc)

	might do some operator overloading python or lua style

	function value could implement with pointer-to-code and pointer-to-closure
	for a class function we could use the "self" object as the closure
	for a free function the closure is the containing scope
	captured scopes will need to capture parent scopes as well (up to module or function boundary)
	so will need a linked list or something

	some syntax sugar:
		let f = (x, y) {}
		def f(x, y) {}

	this is assumed to be running as part of a game engine
	so make sure the garbage collector can be done in parallel slices multi threaded and deterministic time limits

	also make it possible to jit some of the hot functions / hot loops
	(once we have a bytecode interpreter)

Notes:
	bits of double: 1 sign 11 exp 52 frac
	nan: exp==1, frac!=0
		we will set the top 16 bits to 1
		and use the bottom 48 for whatever
	inf: exp==1, frac==0
	zero:exp==0, frac==0
	nan happens when exp is all 1, frac is non-zero (sign bit ignored)
	quick and safe to set first 16 bits to 1, and use the remaining 48 bits for whatever


