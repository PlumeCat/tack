" Generate a randomized binary tree, and calculate the longest path from the root containing only unique elements. "
" Note that the `distinct` tracker is implemented with an array "
" which makes it O(N) to check for an existing element in a path "
" once the object type can accept any type as key, this can be improved to O(1)"

export fn make_tree(maxdepth) {
    if maxdepth > 0 {
        let l = null
        let r = null
        if random() < 0xcfff {
            l = make_tree(maxdepth - 1)
        }
        if random() < 0xcfff {
            r = make_tree(maxdepth - 1)
        }

        return {
            left = l,
            right = r,
            data = random() % (maxdepth * 2)
        }
    }
    return null
}

fn print_tree(t) {
    fn f(t, prefix) {
        if t {
            print(     prefix + "data=" + tostring(t.data))
            f(t.left,  prefix + "    ")
            f(t.right, prefix + "    ")
        }
    }
    f(t, "")
}

fn visit(tree, distinct, path_length, dir) {
    if tree.data in distinct {
        return path_length
    }
    path_length = path_length + 1
    
    distinct << tree.data

    let path_length_r = 0
    let path_length_l = 0

    if tree.left != null {
        path_length_l = visit(tree.left, distinct, path_length, "left")
    }
    if tree.right != null {
        path_length_r = visit(tree.right, distinct, path_length, "right")
    }

    distinct >> 1

    return max(path_length_l, path_length_r)
}


fn longest_distinct_path(tree) {
    const distinct = []
    return visit(tree, distinct, 0, "root")
}


const tree = make_tree(8)
print("-------------------------------------------")

print_tree(tree)

const res = longest_distinct_path(tree)
print("-------------------------------------------")
print("RESULT:")
print(res)
print("-------------------------------------------")
