TODO:
    parser:
        X handle more binary operators
        - correct operator precedence
        X handle chained postfix operators  eg hof()(), aoa[1][2]
        X handle single-argument functions
        X index operator
        - specialise parse_string for 1 character - use invisibly in macro'd rules!
        - multithread imports
        - better error messages
        - check that associativity is working for all binary operators
            want '/', '-', '%' to l-associate, but will r-associate due to r-recursive grammar...
        X unify macro approach (or define grammar combinators)
            - ALL parsing rules should be macro'd
        - get rid of the "success" blocks
        X improve right-recursive parsing
        X implement something for left-recursive rules
        X parse_program broken??? we are hacking to use block :|
            tricky because EOF acceptable as terminator
        - very inefficient, can we improve? side effect of naive rec-desc?
            - nested TRY will help with this; only parse common leading elements once
            - tighten up the whitespace rules, this will allow to early-out a lot of rules by peeking 1 or 2 chars
        - specify ast schema, add validation (subclasses?)
        - find a good way of checking exhaustively for ambiguities (and even for resolving them)
            - ordering of TRY is significant in causing ambiguities
            - during parsing, when ambiguity is resolved, can use to generate very specific error messages
            - for now, should be able to:
                - generate error messages at a block level when an incorrect program_part is detected
                - then skip to end of block somehow and attempt to resume

    syntax:
        - can we omit brackets for function literals?

    reference vm:
        X intern functions (source code can only contain so many functions :D)
        - handle builtins properly, maybe a bottom-level scope?
            a = print; a("hello world") should work but currently doesn't
        - bytecode generation
            - then can cache bytecodes between runs

    jitter:
        - remove "custom" strings; make as array of char
        - extension of the reference vm

    language:
        X strings
        X arrays
        X if/else
        X looping
        X range literals!
        - proper binding of c functions
        - custom data structures
            - labelled product type
            - sum type
        - static typing
        - comments
        - stdlib
        - match?
        - imports
        - closures somehow
        - remove special string, make list of char

    other:
        - some unit tests!!
        - fix the REPL
            - make the top-level parse a program-part
            - evaluate as we go
            - handle multilines nicely
        - have an optimising compiler
            - [automatic] threading
            - memory management
