Grammar:
	block
		'{' stat-list '}'
	
	var-decl
		'let' ident '=' exp

	assign-stat
		access-exp '=' exp
		index-exp  '=' exp
		ident '=' exp

	exp:
		ternary-exp
			binary-exp '?' ternary-exp ':' ternary-exp
			binary-exp

	binary-exp
		or-exp		and-exp [ || or-exp ]			// left-assoc because of short circuiting
		and-exp		bit-or-exp [ && and-exp ]		// left-assoc because of short circuiting

		bit-or-exp	bit-xor-exp [ | bit-or-exp ]	// left assoc
		bit-xor-exp	bit-and-exp [ ^ bit-xor-exp ]	// associative
		bit-and-exp cmp-exp [ & bit-and-exp ]		// associative

		cmp-exp		shl-exp [ cmp-op cmp-exp ]		// TODO: don't allow chained comparisons a == b == c

		shl-exp		shr-exp [ << shl-exp ]			// left associative
		shr-exp		add-exp [ >> adr-exp ]			// left associative

		add-exp		sub-exp [ + add-exp ]			// associative
		sub-exp		mul-exp	[ - sub-exp ]			// left associative
		mul-exp		div-exp [ * mul-exp ]			// associative
		div-exp		mod-exp [ / div-exp ]			// left associative
		mod-exp		pow-exp [ % mod-exp ]			// left associative
		pow-exp		unary-exp [ ** pow-exp ]		// left associative
		
	unary-exp
		'-' unary-exp
		'!' unary-exp
		'~' unary-exp
		postfix-exp

	postfix-exp
		call-exp
		access-exp
		index-exp
		primary-exp

		call-exp
			postfix-exp '(' args-list ')'

		access-exp
			postfix-exp '.' identifier
		
		index-exp
			postfix-exp '[' exp ']'

	primary-exp
		literal
		identifier
		'(' exp ')'

	literal
		'null'
		'true'
		'false'
		literal-number
		literal-string
		literal-object
		literal-array
		literal-function

Instructions:
	from abusive testing, lua allows only 200 local variables
	if you then try and call a function and pass them all, it will complain
	on the 55th argument

	seeing as all arguments must be on the stack, safe to assume the function
	only has 256 "registers" to play with

	however should not need that many; 200 local variables is perverse
	also make sure to reuse registers where the variable has gone out of scope
	(not sure if Lua does this)

	lua is known to use 32bit instructions, so safe to assume
	there are 8bits for opcode then 3x 8bit operands

	from also abusive testing, lua can jump over about 1<<23 instructions
	so presumably using all 3 operands for jumps

	lua only has JMP, not CONDJUMP, instead the EQ type instructions
	are used to implement condjumps; EQ conditionally jumps the next
	instruction, so you can schedule an unconditional jump straight after
	to implement condjump

	we do something similar called CONDSKIP

Objects, arrays, closures
	objects will need some kind of 'prototype' or 'index' field to implement classes
		- or can use copydown ES5 style
		- could add a magic 'this' keyword, which is valid inside the body of an object literal and refers to the object itself

	arrays are true arrays, not just object in disguise

Insert/remove while iterating
	From code:
		Needs to be predictable
		EG throw an obvious comprehensible error instead of segfaulting or silently continuing with corrupted memory
		Lua:
			manual 5.4: "You should not assign any value to a non-existent field in a table during its traversal. You may however modify existing fields. In particular, you may set existing fields to nil."
			presumably this includes appending to the 'array' part
		javascript:
			length is always accurate for arrays seemingly, so array splice/remove for a classic for loop should work as expected
			EG array.forEach processes the range in advance, so won't handle appended elements
			objects 
		python:
			Discouraged for lists, unclear for dict or other mutable collections

Exceptions / error handling
	The interpreter loop is stackless - maintains its own stack, doesn't use the C stack
	This means we don't need exceptions, longjmp, goto or anything
	too problematic for error handling. Instead we can just jump out of the interpreter loop
	to a defined error handler, maintain the program state and provide the option
	to jump back in.
	
	For example if C code calls a function and provides an error handler, if instruction N
	causes an error (eg trying to call a non-function) we can let the error handler
	decide whether to continue or not from instruction N+1 (or can jump to a different error handler instruction)
	(although it is likely the program continues to malfunction if the assumption is that instruction N was executed)
	eg:
		void foo() {
			tack_error_handler([](int error_code, const char* error_msg) -> int {
				if (error_code == MISSING_FILE) {
					return TACK_CONTINUE;
				} else{
					log("Unrecoverable error: ", error_msg);
					return TACK_EXIT;
				}
			})
			tack_execute(program) // throws a tack error
		}

Types
	Type analysis might be useful for optimization
	eg.
		let c = a + b
	what are the types of a and b? number, string, array, other?
	normally we need to emit typechecks when performing the add
	so we would have to treat the normal ADD instruction as possibly having any types
	however if the types of a and b are known, then we can emit a faster opcode that skips the checks
		ADD_ANY vs ADD_NUM, ADD_STR, ADD_ARRAY
	this also allows us to deduce the type of c, which can be used later in expressions involving c, etc etc
	
	so how to deduce the types? if assigned from literals, it's easy enough
		let a = 0
		let b = 1
		let greeting = "hello world"
		let foo = { ... }
	the ast can be walked and every expression can be type-deduced as much as possible.
	then when emitting code, we use the deduced type information

	if a function has no return sites, then the return type is null (?)
	otherwise it's the union of all the types of all the return sites.
	as every function has the implicit final return, it will be useful to elide this (as it adds null everywhere, which is not desirable)
	(It will be useful to mark dead code after a return statement, or maybe forbid it syntactically like lua does)
	This dead code removal can be used to elide the final implicit 'return null'
	(in fact, prioritize this as it's currently cluttering the bytecode)

	We can do some compile-time type checking for free at this point eg
		let a = fn() { return "foo" } let b = a() let c = 1 + b
	should be able to detect an error immediately without having to actually execute the code

	now once we have jitted the code (lol), the branch predictor will come to our aid
	for example a generic add looks like this: (pseudocode)
		if (type(a) == INT && type(b) == INT) {
			ADD_INT
		} else if (type(b) == STR && type(b) == STR) {

		} ... {
			...
		} else {
			error()
		}
	for any given function, it is likely to be used for one particular type 

	inline caching and monomorphization:
	call signature: the type resulting from the product of the argument types for a function call site
	prediction: most call signatures will be the same, with the odd change
	eg:
		f(1, 2, 3);		// CS = tuple<int,int,int>;
		f(1, 2, "foo"); // CS = tuple<int,int,string>;
		( For variadic functions/calls, the variadic part will be treated like an array,
		but perhaps is possible to monomorphize arrays as well?)

		emit different code for each call signature, and if possible use type deduction at the call site
		to decide which code to call
		inline caching: deciding the call at runtime as quickly as possible.

Notes:
	Functions vs closures vs "quasi-closures"

	Any captures have to be auto-boxed because of the possibility of reassign
	All captures are resolved at compile time but boxing currently happens at runtime

	A "quasi closure" is a closure that captures variables from the outer scope,
	but itself is not used by the outer scope / does not escape the outer scope.

	Worth investigating whether it can get its captures from the stack (eg with negative offsets) instead of needing to box. 

	Eg a function used as a sorting predicate

		fn quasi_closure_test() {
			let foo = 1
			
			// predicate() is a quasi-closure
			fn predicate() {
				// Capture a variable from the parent scope
				if foo {
					...
				}
			}

			// Use predicate in this function
			sorted_data = sort(some_data, predicate)
		}

	In this case the call stack has 'sort' in the call stack, ie
		quasi_closure_test -> sort -> predicate
	So will need to know where the captures will be in the stack - there may be
	more indirections as well, it will not be deterministic at compile time

	Another special case for closures is a recursive named function
	The code emitted is something like this
		fn foo() {
			...
			foo(...)
			..
		}
		->
		const foo = fn() {
			...
			foo(...)
		}
	
	so foo has to capture itself from the enclosing scope.
	might be worth optimising this case
	lua appears to set the function as an upvalue
	(for a recursive non-named function we need acrobatics like the y-combinator
	iiuc Y() is doing something equivalent where the function itself uses
	a 'recurse' variable which is then contorted to point to itself)
		on further reading, x => y => y(x) is capturing x from a higher scope

	we could do something like always put a function in its own registers
	eg at position 0

	could have a "recurse" keyword; will call the function at REGISTER(-3)
