# PROGRAM

program         = { declaration | assignment | expression }


program-part    = declaration sep
                | assignment sep
                | expression sep

declaration     = var-decl
                | type-decl


# VARIABLES

var-decl        = "let" name
                | "let" name ':' name
                | "let" name '=' expression
                | "let" name ':' name '=' expression

# TYPES

type-decl       = "type" name type-def

type-def        = product-type-def
                | sum-type-def


# ASSIGNMENTS

assignment      = locator assign-op expression

locator         = locator '[' exp ']'
                | locator '.' name
                | name
                # Omitted "rvalue" assignments eg (eg x.get_y().z = 2)
                # Rationale: In this example get_y() is returned by value
                # so the new value "2" doesn't survive beyond this line
                # as we only have the "pure value" value category

# EXPRESSIONS

expression      = block
                | binary-exp

block           = '{' '}'
                | '{' program '}'

for-exp         = "for" name "in" exp block

if-exp          = "if" exp block

binary-exp      = bool-or-exp

# BINARY EXPRESSIONS
# lower down will have higher precedence
# note that cmp doesn t chain like the others

bool-or-exp     = bool-and-exp "||"     bool-and-exp
                | bool-and-exp
bool-and-exp    = cmp-exp      "&&"     bool-and-exp
                | cmp-exp
cmp-exp         = bit-or-exp   cmp-op   bit-or-exp
                | bit-or-exp
bit-or-exp      = bit-and-exp  '|'      bit-and-exp
                | bit-and-exp
bit-and-exp     = bit-xor-exp  '&'      bit-and-exp
                | bit-xor-exp
bit-xor-exp     = lshift-exp   '^'      bit-xor-exp
                | lshift-exp
lshift-exp      = rshift-exp   '<<'     lshift-exp
                | rshift-exp
rshift-exp      = add-exp      '>>'     rshift-exp
                | add-exp
add-exp         = sub-exp       '+'     add-exp
                | sub-exp
sub-exp         = mul-exp       '-'     sub-exp
                | mul-exp
mul-exp         = div-exp       '*'     mul-exp
                | div-exp
div-exp         = mod-exp       '/'     div-exp
                | mod-exp
mod-exp         = unary-exp     '%'     mod-exp
                | unary-exp

# UNARY EXPRESSIONS

unary-exp       = unary-op unary-exp
                | postfix-exp


postfix-exp     = postfix-exp calling
                | postfix-exp indexing
                | primary-exp
                # handled left-recursion here with parsing gymnastics

indexing        = '[' exp ']'

calling         = '(' [ param_list ] ')'

param_list      = expression { , expression }

primary-exp     = '(' expression ')'
                | number-literal
                | string-literal
                | func-literal
                | array-literal
                | name

name            = `a-zA-Z_{a-z|A-Z|0-9|_}`
number-literal  = ...
string-literal  = ...
func_literal    = '(' [ arg_decl ] ')' '->' expression
arg_decl        = name { , name }
sep             = ';' | '\n'
